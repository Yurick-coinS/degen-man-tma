<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>DEGEN-MAN: Solana Edition</title>
  <style>
    :root { --board-size: 300px; }
    body {
      margin: 0; padding: 0; background-color: #0f0f1a; color: #fff;
      font-family: 'Courier New', monospace;
      display: flex; justify-content: center; align-items: center;
      min-height: 100vh; overflow: hidden; touch-action: none;
    }
    .game-container {
      width: 100%; max-width: 400px; text-align: center; padding: 10px;
      display: flex; flex-direction: column; align-items: center;
    }
    .game-board-wrapper {
      width: 100%; max-width: 300px; max-height: 300px; aspect-ratio: 1 / 1;
      margin: 10px auto; display: flex; justify-content: center;
    }
    .game-board {
      width: var(--board-size); height: var(--board-size);
      border: 3px solid #9945FF; position: relative; background-color: #000;
      box-shadow: 0 0 20px #9945FF; overflow: hidden;
    }
    .player, .ghost, .candle, .wall, .bullet { position: absolute; }
    .player { width: 15px; height: 15px; z-index: 10; }
    .ghost { width: 15px; height: 15px; z-index: 5; }
    .candle { width: 4px; height: 4px; z-index: 3; border-radius: 50%; background-color: #FFD700; box-shadow: 0 0 6px #FFD700; }
    .candle.power-candle { width: 10px; height: 10px; background-color: #00FFFA; box-shadow: 0 0 12px #00FFFA, 0 0 4px #00FFFA; border: 2px solid #fff; }
    .wall { background-color: #14F195; z-index: 2; border-radius: 2px; box-shadow: 0 0 10px #14F195, 0 0 2px #14F195; }
    .bullet { width: 6px; height: 6px; border-radius: 50%; background: #00FFFA; box-shadow: 0 0 8px #00FFFA; z-index: 20; pointer-events: none; }
    .title { color: #9945FF; font-size: 32px; margin-bottom: 5px; text-shadow: 0 0 8px #9945FF; font-weight: bold; }
    .subtitle { color: #14F195; font-size: 14px; margin-bottom: 5px; }
    .score-panel { display: flex; justify-content: space-between; width: 100%; max-width: var(--board-size); margin: 5px auto; font-size: 16px; color: #14F195; }
    .btn { background-color: #9945FF; color: white; border: none; padding: 10px 20px; cursor: pointer; margin-top: 10px; font-size: 16px; font-weight: bold; border-radius: 4px; transition: all 0.3s; }
    .btn:hover { background-color: #7d37cc; box-shadow: 0 0 8px #9945FF; }
    .controls { margin-top: 8px; color: #666; font-size: 14px; }
    .game-over, .level-complete, .start-screen {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.85);
      display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100;
    }
    .level-indicator { position: absolute; top: 8px; left: 8px; color: #14F195; font-size: 14px; z-index: 5; }
    /* --- Геймпад --- */
    .gamepad {
      position: fixed;
      left: 0; right: 0; bottom: 0;
      width: 100vw; max-width: 400px;
      height: 120px;
      display: flex; justify-content: space-between; align-items: flex-end;
      pointer-events: none;
      z-index: 200;
      margin: 0 auto;
      user-select: none;
    }
    .dpad, .abtns { pointer-events: auto; }
    .dpad {
      width: 110px; height: 110px; margin-left: 10px; position: relative;
      display: flex; justify-content: center; align-items: center;
    }
    .dpad-btn {
      position: absolute;
      width: 48px; height: 48px;
      background: rgba(153,69,255,0.7);
      border-radius: 16px;
      display: flex; justify-content: center; align-items: center;
      font-size: 28px; color: #fff; font-weight: bold;
      border: 2px solid #9945FF;
      box-shadow: 0 0 8px #9945FF;
      transition: background 0.1s, transform 0.1s;
      user-select: none;
    }
    .dpad-btn:active { background: #9945FF; transform: scale(0.95); }
    .dpad-up    { top: 0; left: 31px; }
    .dpad-down  { bottom: 0; left: 31px; }
    .dpad-left  { left: 0; top: 31px; }
    .dpad-right { right: 0; top: 31px; }
    .abtns {
      width: 110px; height: 110px; margin-right: 10px; position: relative;
      display: flex; justify-content: center; align-items: center;
    }
    .abtn {
      position: absolute;
      right: 0; bottom: 0;
      width: 60px; height: 60px;
      background: rgba(0,255,250,0.8);
      border-radius: 50%;
      display: flex; justify-content: center; align-items: center;
      font-size: 28px; color: #fff; font-weight: bold;
      border: 2px solid #00FFFA;
      box-shadow: 0 0 12px #00FFFA;
      transition: background 0.1s, transform 0.1s, opacity 0.2s;
      user-select: none;
      z-index: 1;
      opacity: 0.4;
      pointer-events: auto;
    }
    .abtn.active {
      opacity: 1;
      background: rgba(0,255,250,0.8);
      pointer-events: auto;
    }
    .abtn:active { background: #00FFFA; opacity: 1; transform: scale(0.95); }
    @media (max-width: 500px) {
      .title { font-size: 26px; margin-bottom: 2px; }
      .subtitle { font-size: 13px; margin-bottom: 5px; }
      .score-panel { font-size: 14px; margin: 3px auto; }
      .controls { display: none; }
      .btn { padding: 8px 16px; font-size: 14px; }
      .gamepad { height: 90px; }
      .dpad, .abtns { width: 80px; height: 80px; }
      .dpad-btn { width: 34px; height: 34px; font-size: 20px; }
      .abtn { width: 44px; height: 44px; font-size: 20px; }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <div class="game-info">
      <div class="title">DEGEN-MAN</div>
      <div class="subtitle">THE MAZE OF F.U.D.</div>
      <div class="score-panel">
        <div>$POOR: <span id="score">0</span></div>
        <div>LIVES: <span id="lives">3</span></div>
      </div>
    </div>
    <div class="game-board-wrapper">
      <div class="game-board" id="game-board">
        <div class="level-indicator" id="level-indicator">LEVEL 1</div>
        <div class="start-screen" id="start-screen">
          <h2>DEGEN-MAN</h2>
          <p>Collect green candles. Avoid F.U.D.<br>
          <b>Power-candle</b>: shoot with <kbd>Space</kbd>, <kbd>J</kbd> or <b>A</b> button!</p>
          <button class="btn" id="start-btn">START GAME</button>
        </div>
        <div class="game-over" id="game-over" style="display: none;">
          <h2>GAME OVER</h2>
          <p>Final Score: <span id="final-score">0</span></p>
          <p>Level Reached: <span id="final-level">1</span></p>
          <button class="btn" id="restart-btn">TRY AGAIN</button>
        </div>
        <div class="level-complete" id="level-complete" style="display: none;">
          <h2>LEVEL <span id="completed-level">1</span> COMPLETE!</h2>
          <p>Current Score: <span id="level-score">0</span></p>
          <p>Get ready for the next level...</p>
        </div>
      </div>
    </div>
    <div class="controls">Use arrow keys or WASD to move. Shoot: <kbd>Space</kbd>, <kbd>J</kbd> or <b>A</b> button</div>
    <!-- Геймпад -->
    <div class="gamepad" id="gamepad">
      <div class="dpad">
        <div class="dpad-btn dpad-up"    id="dpad-up">&#9650;</div>
        <div class="dpad-btn dpad-down"  id="dpad-down">&#9660;</div>
        <div class="dpad-btn dpad-left"  id="dpad-left">&#9664;</div>
        <div class="dpad-btn dpad-right" id="dpad-right">&#9654;</div>
      </div>
      <div class="abtns">
        <div class="abtn" id="abtn-a"><span>A</span></div>
      </div>
    </div>
  </div>
  <script>
    // --- Web Audio API: простые звуки ---
    let audioCtx;
    function playTone(freq, duration = 0.1, type = "sine", volume = 0.2) {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      gain.gain.value = volume;
      osc.connect(gain).connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + duration);
      osc.onended = () => { osc.disconnect(); gain.disconnect(); };
    }
    function playCandleSound() { playTone(880, 0.07, "triangle", 0.15); }
    function playPowerCandleSound() { playTone(440, 0.18, "square", 0.18); }
    function playDeathSound() { playTone(110, 0.25, "sawtooth", 0.22); }
    function playLevelSound() {
      playTone(523, 0.08, "triangle", 0.18);
      setTimeout(() => playTone(659, 0.08, "triangle", 0.18), 90);
      setTimeout(() => playTone(784, 0.12, "triangle", 0.18), 180);
    }

    // --- остальной код ---
    const wallStyles = [
      { color: "#27ae60", shadow: "#145a32", radius: "8px", texture: "none" },
      { color: "#39ff14", shadow: "#0f3d0f", radius: "12px", texture: "none" },
      { color: "#4CAF50", shadow: "#1B5E20", radius: "20px", texture: "none" },
      { color: "#bdbdbd", shadow: "#616161", radius: "2px", texture: "none" },
      { color: "#607d8b", shadow: "#263238", radius: "0px", texture: "none" },
      { color: "#ff9800", shadow: "#e65100", radius: "0px", texture: "linear-gradient(90deg, #ff9800 80%, #e65100 100%)" },
      { color: "#795548", shadow: "#3e2723", radius: "6px", texture: "repeating-linear-gradient(45deg, #8d6e63, #8d6e63 4px, #795548 4px, #795548 8px)" },
      { color: "#00bcd4", shadow: "#006064", radius: "50%", texture: "repeating-radial-gradient(circle, #00bcd4, #b2ebf2 10px)" },
      { color: "#9c27b0", shadow: "#4a148c", radius: "10px", texture: "repeating-linear-gradient(135deg, #9c27b0, #4a148c 10px)" },
      { color: "#e0f7fa", shadow: "#00bcd4", radius: "4px", texture: "repeating-linear-gradient(45deg, #e0f7fa, #b2ebf2 8px)" },
      { color: "#fbc02d", shadow: "#ff8f00", radius: "0px", texture: "repeating-linear-gradient(90deg, #fbc02d, #ffe082 10px)" },
      { color: "#789262", shadow: "#3e4d34", radius: "16px", texture: "none" },
      { color: "#757575", shadow: "#212121", radius: "0px", texture: "repeating-linear-gradient(135deg, #757575, #bdbdbd 10px)" },
      { color: "#00e676", shadow: "#00b248", radius: "50%", texture: "repeating-radial-gradient(circle, #00e676, #b2ff59 8px)" },
      { color: "#ffeb3b", shadow: "#fbc02d", radius: "20px", texture: "repeating-linear-gradient(45deg, #ffeb3b, #fff176 10px)" },
      { color: "#e91e63", shadow: "#880e4f", radius: "10px", texture: "repeating-linear-gradient(135deg, #e91e63, #f8bbd0 10px)" },
      { color: "#00bfae", shadow: "#00695c", radius: "50%", texture: "repeating-radial-gradient(circle, #00bfae, #1de9b6 8px)" },
    ];

    // --- Символы: P - игрок, F - fomo, R - rug, V - volatility, A - paper ---
    const mazeLayouts = [
      [
        "#.################.#",
        "#..F.....##........#",
        "#.##.###.##.###.##.#",
        "#.#..............#.#",
        "#.#.##.######.##.#.#",
        "#....*...##...*....#",
        "#.##.#.#.##.#.#.##.#",
        "#.#..............#.#",
        "#.#.##.######.##.#.#",
        ".............P......",
        "#.#.##.######.##.#.#",
        "#.#..............#.#",
        "#.##.#.#.##.#.#.##.#",
        "#....*...##...*....#",
        "#.#.##.######.##.#.#",
        "#.#..R...........#.#",
        "#.##.###.##.###.##.#",
        "#........##........#",
        "#.....########.....#",
        "#.################.#"
      ],
      [
        "#.################.#",
        "#.....########.....#",
        "#....*........F....#",
        "#.##..###..###.*##.#",
        "#.#....#....#....#.#",
        "#.#....#....#....#.#",
        "#...##........##.R.#",
        "###..#...##...#..###",
        "##.....######.....##",
        "#......*####.......#",
        "#...##...##...##...#",
        "##......####......##",
        "###..#.######.#..###",
        "#...##...##...##...#",
        "#.#....#..*.#....#.#",
        "#.#....#....#....#.#",
        "#.##..###..###..##.#",
        "#.....P............#",
        "#.....########.....#",
        "#.################.#"
      ],
      [
        "####################",
        "#..*..........F....#",
        "#.##.##..##..##.##.#",
        "#.##.##.####.##.##.#",
        "#........##........#",
        "#.##.#.######.#.##.#",
        "#....#...##...#..*.#",
        "####.###.##.###.####",
        "#...R..#....#......#",
        "#.####.#.##.#.####.#",
        "#.*..#........#....#",
        "##.#.##########.#.##",
        "#..#............#..#",
        "..##.###....###.##..",
        "#....#........#....#",
        "#.######.##.######.#",
        "#........##........#",
        "#*##.##.####.##.##.#",
        "#........P.........#",
        "####################"
      ],
      [
         "####################",
         "#.F................#",
         "#.#..#..####..#.*#.#",
         "#..##..######..##..#",
         "#.#..#...##...#..#.#",
         "#.##.###....###.##.#",
         "#....#...##...#R...#",
         "###*.##.####.##..###",
         "#.......#..#.......#",
         "#..####.#..#.####..#",
         "..........*.........",
         "##.##.#.####.#.##.##",
         "#..#............#..#",
         "#.##..##....##..##.#",
         "#...##........##...#",
         "#.######.##.######.#",
         "#..##....*.....##..#",
         "#.#..#.######.#..#.#",
         "#........P.........#",
         "####################"
      ]
    ];

    const gameBoard = document.getElementById('game-board');
    const scoreElement = document.getElementById('score');
    const livesElement = document.getElementById('lives');
    const startBtn = document.getElementById('start-btn');
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over');
    const levelCompleteScreen = document.getElementById('level-complete');
    const finalScoreElement = document.getElementById('final-score');
    const finalLevelElement = document.getElementById('final-level');
    const completedLevelElement = document.getElementById('completed-level');
    const levelScoreElement = document.getElementById('level-score');
    const levelIndicator = document.getElementById('level-indicator');
    const restartBtn = document.getElementById('restart-btn');
    // Геймпад
    const dpadUp = document.getElementById('dpad-up');
    const dpadDown = document.getElementById('dpad-down');
    const dpadLeft = document.getElementById('dpad-left');
    const dpadRight = document.getElementById('dpad-right');
    const abtnA = document.getElementById('abtn-a');

    let player;
    let ghosts = [];
    let candles = [];
    let walls = [];
    let bullets = [];
    let score = 0;
    let lives = 3;
    let level = 1;
    let gameRunning = false;
    let gameInterval;
    const CELL_SIZE = 15;
    const GRID_WIDTH = 20;
    const GRID_HEIGHT = 20;
    const PLAYER_SIZE = 15;
    const GHOST_SIZE = 15;
    const CANDLE_SIZE = 4;
    let BOARD_WIDTH = 300;
    let BOARD_HEIGHT = 300;
    let scaleX = 1;
    let scaleY = 1;
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

    let powerMode = false;
    let powerModeTimeout = null;

    // Для анимации рта игрока
    let playerMouthOpen = false;
    let playerMouthAnimTimer = 0;

    // --- Движение игрока ---
    let playerDirection = { x: 0, y: 0 };
    let playerNextDirection = { x: 0, y: 0 };
    let playerX = 0;
    let playerY = 0;

    // --- Новое: стартовые позиции ---
    let playerStart = null;
    let ghostStarts = [];

    function applyWallStyle(level) {
      const style = wallStyles[(level - 1) % wallStyles.length];
      document.documentElement.style.setProperty('--wall-color', style.color);
      document.documentElement.style.setProperty('--wall-shadow', style.shadow);
      document.documentElement.style.setProperty('--wall-radius', style.radius);
      document.documentElement.style.setProperty('--wall-texture', style.texture || "none");
    }

    function adjustGameBoardSize() {
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      let maxBoardSize;
      if (window.matchMedia('(orientation: portrait)').matches) {
        maxBoardSize = Math.min(windowWidth - 20, windowHeight * 0.5);
      } else {
        maxBoardSize = Math.min(windowWidth * 0.6, windowHeight - 100);
      }
      BOARD_WIDTH = maxBoardSize;
      BOARD_HEIGHT = maxBoardSize;
      document.documentElement.style.setProperty('--board-size', `${maxBoardSize}px`);
      scaleX = maxBoardSize / 300;
      scaleY = maxBoardSize / 300;
      if (gameRunning && player) updateAllElementPositions();
    }
    function updateAllElementPositions() {
      player.style.left = (playerX * scaleX) + 'px';
      player.style.top = (playerY * scaleY) + 'px';
      player.style.transform = `scale(${scaleX}, ${scaleY}) rotate(${getPlayerRotation()}deg)`;
      ghosts.forEach(ghost => {
        ghost.element.style.left = (ghost.x * scaleX) + 'px';
        ghost.element.style.top = (ghost.y * scaleY) + 'px';
        ghost.element.style.transform = `scale(${scaleX}, ${scaleY})`;
      });
      candles.forEach(candle => {
        candle.element.style.left = (candle.x * scaleX) + 'px';
        candle.element.style.top = (candle.y * scaleY) + 'px';
        candle.element.style.transform = `scale(${scaleX}, ${scaleY})`;
      });
      walls.forEach(wall => {
        wall.element.style.left = (wall.x * scaleX) + 'px';
        wall.element.style.top = (wall.y * scaleY) + 'px';
        wall.element.style.width = (CELL_SIZE * scaleX) + 'px';
        wall.element.style.height = (CELL_SIZE * scaleY) + 'px';
      });
      bullets.forEach(b => {
        b.element.style.left = (b.x * scaleX) + 'px';
        b.element.style.top = (b.y * scaleY) + 'px';
      });
    }
    function getPlayerRotation() {
      if (playerDirection.x === 1) return 0;
      else if (playerDirection.x === -1) return 180;
      else if (playerDirection.y === -1) return 270;
      else if (playerDirection.y === 1) return 90;
      return 0;
    }
    function createPlayerSvg(mouthOpen = false) {
      return `
      <svg width="15" height="15" viewBox="0 0 15 15" xmlns="http://www.w3.org/2000/svg">
        <circle cx="7.5" cy="7.5" r="6" fill="#FFD6A5"/>
        <path d="M2 6C2 4 4 2.5 7.5 2.5C11 2.5 13 4 13 6H2Z" fill="#000"/>
        <path d="M6 2L7.5 1L9 2" fill="#000"/>
        <text x="6.5" y="6" font-size="2.5" fill="#14F195">S</text>
        <rect x="5" y="6" width="5" height="1.5" rx="0.5" fill="#FFF"/>
        ${
          mouthOpen
            ? `<path d="M5 9 Q7.5 13 10 9" stroke="#000" fill="#000" stroke-width="0.4"/>`
            : `<path d="M5 9 Q7.5 8.5 10 9" stroke="#000" fill="none" stroke-width="0.4"/>`
        }
      </svg>`;
    }
    function createGhostSvg(type) {
      let color, eyeColor, mouthPath;
      switch(type) {
        case 'fomo': color = '#FF0000'; eyeColor = '#FFF'; mouthPath = 'M5 10Q7.5 12 10 10'; break;
        case 'rug': color = '#FF69B4'; eyeColor = '#FFF'; mouthPath = 'M5 11Q7.5 9 10 11'; break;
        case 'volatility': color = '#00BFFF'; eyeColor = '#FFF'; mouthPath = 'M5 10L10 10'; break;
        case 'paper': color = '#FFA500'; eyeColor = '#FFF'; mouthPath = 'M5 11Q7.5 10 10 11'; break;
      }
      return `
      <svg width="15" height="15" viewBox="0 0 15 15" xmlns="http://www.w3.org/2000/svg">
        <path d="M1.5 7.5 
                 C1.5 4.5 3.5 1.5 7.5 1.5 
                 C11.5 1.5 13.5 4.5 13.5 7.5 
                 L13.5 12 
                 C13.5 12 12 10.5 11 12 
                 C10 13.5 9 12 8 12 
                 C7 12 6 13.5 5 12 
                 C4 10.5 3 12 3 12 
                 L1.5 7.5Z"
          fill="${color}" />
        <circle cx="5" cy="6" r="1" fill="${eyeColor}" />
        <circle cx="10" cy="6" r="1" fill="${eyeColor}" />
        <circle cx="5" cy="6" r="0.5" fill="#000" />
        <circle cx="10" cy="6" r="0.5" fill="#000" />
        <path d="${mouthPath}" stroke="#000" fill="none" stroke-width="0.4" />
      </svg>`;
    }

    // --- Новый createMaze с поддержкой стартовых позиций ---
    function createMaze(levelIndex) {
      playerStart = null;
      ghostStarts = [];
      const layout = mazeLayouts[levelIndex] || mazeLayouts[0];
      for (let y = 0; y < layout.length; y++) {
        for (let x = 0; x < layout[y].length; x++) {
          const cell = layout[y][x];
          if (cell === '#') {
            const wall = document.createElement('div');
            wall.className = 'wall';
            wall.style.left = (x * CELL_SIZE * scaleX) + 'px';
            wall.style.top = (y * CELL_SIZE * scaleY) + 'px';
            wall.style.width = (CELL_SIZE * scaleX) + 'px';
            wall.style.height = (CELL_SIZE * scaleY) + 'px';
            gameBoard.appendChild(wall);
            walls.push({
              x: x * CELL_SIZE,
              y: y * CELL_SIZE,
              width: CELL_SIZE,
              height: CELL_SIZE,
              element: wall
            });
          } else if (cell === '.') {
            const cx = x * CELL_SIZE + (CELL_SIZE - CANDLE_SIZE) / 2;
            const cy = y * CELL_SIZE + (CELL_SIZE - CANDLE_SIZE) / 2;
            createCandleAt(cx, cy);
          } else if (cell === '*') {
            const cx = x * CELL_SIZE + (CELL_SIZE - 10) / 2;
            const cy = y * CELL_SIZE + (CELL_SIZE - 10) / 2;
            createPowerCandleAt(cx, cy);
          } else if (cell === 'P') {
            playerStart = {
              x: x * CELL_SIZE + (CELL_SIZE - PLAYER_SIZE) / 2,
              y: y * CELL_SIZE + (CELL_SIZE - PLAYER_SIZE) / 2
            };
          } else if (cell === 'F' || cell === 'R' || cell === 'V' || cell === 'A') {
            ghostStarts.push({
              type: cell,
              x: x * CELL_SIZE + (CELL_SIZE - GHOST_SIZE) / 2,
              y: y * CELL_SIZE + (CELL_SIZE - GHOST_SIZE) / 2
            });
          }
        }
      }
    }

    function createCandleAt(x, y) {
      for (const candle of candles) {
        const dx = candle.x - x;
        const dy = candle.y - y;
        if (Math.hypot(dx, dy) < 10) return;
      }
      const candle = document.createElement('div');
      candle.className = 'candle';
      candle.style.left = (x * scaleX) + 'px';
      candle.style.top = (y * scaleY) + 'px';
      gameBoard.appendChild(candle);
      candles.push({
        element: candle,
        x: x,
        y: y
      });
    }
    function createPowerCandleAt(x, y) {
      const candle = document.createElement('div');
      candle.className = 'candle power-candle';
      candle.style.left = (x * scaleX) + 'px';
      candle.style.top = (y * scaleY) + 'px';
      gameBoard.appendChild(candle);
      candles.push({
        element: candle,
        x: x,
        y: y,
        power: true
      });
    }

    // --- Новый createGhosts: спавн по ghostStarts ---
    function createGhosts() {
      ghosts = [];
      ghostStarts.forEach(ghostData => {
        const ghost = document.createElement('div');
        let type;
        switch (ghostData.type) {
          case 'F': type = 'fomo'; break;
          case 'R': type = 'rug'; break;
          case 'V': type = 'volatility'; break;
          case 'A': type = 'paper'; break;
        }
        ghost.className = 'ghost ghost-' + type;
        ghost.style.left = (ghostData.x * scaleX) + 'px';
        ghost.style.top = (ghostData.y * scaleY) + 'px';
        ghost.style.transform = `scale(${scaleX}, ${scaleY})`;
        ghost.innerHTML = createGhostSvg(type);
        gameBoard.appendChild(ghost);
        ghosts.push({
          element: ghost,
          x: ghostData.x,
          y: ghostData.y,
          type: type,
          speed: 1,
          direction: { x: 0, y: 0 },
          nextDirection: { x: 0, y: 0 }
        });
      });
    }

    function createPlayer() {
      player = document.createElement('div');
      player.className = 'player';
      player.style.left = (playerX * scaleX) + 'px';
      player.style.top = (playerY * scaleY) + 'px';
      player.style.transform = `scale(${scaleX}, ${scaleY})`;
      player.innerHTML = createPlayerSvg();
      player.speed = 1.5;
      player.invincible = false;
      player.lastShot = 0;
      gameBoard.appendChild(player);
    }

    function findValidPosition(width, height) {
      let x, y, isValid;
      let attempts = 0;
      const maxAttempts = 100;
      do {
        isValid = true;
        const gridX = Math.floor(Math.random() * GRID_WIDTH);
        const gridY = Math.floor(Math.random() * GRID_HEIGHT);
        x = gridX * CELL_SIZE + (CELL_SIZE - width) / 2;
        y = gridY * CELL_SIZE + (CELL_SIZE - height) / 2;
        for (const wall of walls) {
          if (
            x < wall.x + wall.width &&
            x + width > wall.x &&
            y < wall.y + wall.height &&
            y + height > wall.y
          ) {
            isValid = false;
            break;
          }
        }
        if (isValid && Math.hypot(x - playerX, y - playerY) < 30) isValid = false;
        if (isValid) {
          for (const c of candles) {
            if (Math.hypot(x - c.x, y - c.y) < 15) {
              isValid = false;
              break;
            }
          }
        }
        attempts++;
        if (attempts >= maxAttempts) isValid = true;
      } while (!isValid);
      return { x, y };
    }

    function initGame() {
      applyWallStyle(1);
      const elementsToKeep = [startScreen, gameOverScreen, levelCompleteScreen, levelIndicator];
      const children = Array.from(gameBoard.children);
      for (const child of children) {
        if (!elementsToKeep.includes(child)) gameBoard.removeChild(child);
      }
      score = 0;
      lives = 3;
      level = 1;
      scoreElement.textContent = score;
      livesElement.textContent = lives;
      levelIndicator.textContent = "LEVEL 1";
      ghosts = [];
      candles = [];
      walls = [];
      bullets.forEach(b => gameBoard.removeChild(b.element));
      bullets = [];
      powerMode = false;
      showAButton(false);
      if (powerModeTimeout) clearTimeout(powerModeTimeout);
      createMaze(0);

      // --- Новый спавн игрока и призраков ---
      playerX = playerStart ? playerStart.x : 10 * CELL_SIZE + (CELL_SIZE - PLAYER_SIZE) / 2;
      playerY = playerStart ? playerStart.y : 10 * CELL_SIZE + (CELL_SIZE - PLAYER_SIZE) / 2;
      playerDirection = { x: 0, y: 0 };
      playerNextDirection = { x: 0, y: 0 };
      createPlayer();
      createGhosts();
      createCandles();
    }

    function startGame() {
      if (gameRunning) return;
      gameRunning = true;
      startScreen.style.display = 'none';
      gameOverScreen.style.display = 'none';
      levelCompleteScreen.style.display = 'none';
      gameInterval = setInterval(gameLoop, 30);
    }

    function gameLoop() {
      // Анимация рта игрока
      playerMouthAnimTimer++;
      if (playerMouthAnimTimer > 6) {
        playerMouthOpen = !playerMouthOpen;
        playerMouthAnimTimer = 0;
        player.innerHTML = createPlayerSvg(playerMouthOpen);
      }

      if (playerNextDirection.x !== 0 || playerNextDirection.y !== 0) {
        if (canMove(playerX, playerY, playerNextDirection, PLAYER_SIZE)) {
          playerDirection = { ...playerNextDirection };
        }
      }
      if (playerDirection.x !== 0 || playerDirection.y !== 0) {
        const speed = player.speed || 1.5;
        const nextX = playerX + playerDirection.x * speed;
        const nextY = playerY + playerDirection.y * speed;
        if (canMove(playerX, playerY, playerDirection, PLAYER_SIZE)) {
          playerX = nextX;
          playerY = nextY;
          handleTunnels();
          player.style.left = (playerX * scaleX) + 'px';
          player.style.top = (playerY * scaleY) + 'px';
          player.style.transform = `scale(${scaleX}, ${scaleY}) rotate(${getPlayerRotation()}deg)`;
        }
      }
      moveGhosts();
      moveBullets();
      checkCandleCollection();
      checkGhostCollision();
    }
    function handleTunnels() {
      if (playerX < -PLAYER_SIZE) playerX = 300;
      else if (playerX > 300) playerX = -PLAYER_SIZE;
      if (playerY < -PLAYER_SIZE) playerY = 300;
      else if (playerY > 300) playerY = -PLAYER_SIZE;
      ghosts.forEach(ghost => {
        if (ghost.x < -GHOST_SIZE) ghost.x = 300;
        else if (ghost.x > 300) ghost.x = -GHOST_SIZE;
        if (ghost.y < -GHOST_SIZE) ghost.y = 300;
        else if (ghost.y > 300) ghost.y = -GHOST_SIZE;
        ghost.element.style.left = (ghost.x * scaleX) + 'px';
        ghost.element.style.top = (ghost.y * scaleY) + 'px';
      });
    }
    function canMove(x, y, dir, size) {
      const nextX = x + dir.x * 1;
      const nextY = y + dir.y * 1;
      if (nextX < 0 || nextX > 300 || nextY < 0 || nextY > 300) return true;
      for (const wall of walls) {
        if (
          nextX < wall.x + wall.width &&
          nextX + size > wall.x &&
          nextY < wall.y + wall.height &&
          nextY + size > wall.y
        ) {
          return false;
        }
      }
      return true;
    }
    function moveGhosts() {
      ghosts.forEach(ghost => {
        if (Math.random() < 0.05) {
          let dx = playerX - ghost.x;
          let dy = playerY - ghost.y;
          if (Math.abs(dx) > 150) dx = -Math.sign(dx) * (300 - Math.abs(dx));
          if (Math.abs(dy) > 150) dy = -Math.sign(dy) * (300 - Math.abs(dy));
          ghost.nextDirection = Math.abs(dx) > Math.abs(dy) ? { x: Math.sign(dx), y: 0 } : { x: 0, y: Math.sign(dy) };
        }
        if (ghost.nextDirection.x !== 0 || ghost.nextDirection.y !== 0) {
          if (canMove(ghost.x, ghost.y, ghost.nextDirection, GHOST_SIZE)) {
            ghost.direction = { ...ghost.nextDirection };
            ghost.nextDirection = { x: 0, y: 0 };
          }
        }
        if (!canMove(ghost.x, ghost.y, ghost.direction, GHOST_SIZE)) {
          const directions = [
            { x: 1, y: 0 },
            { x: -1, y: 0 },
            { x: 0, y: 1 },
            { x: 0, y: -1 }
          ];
          for (let i = directions.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [directions[i], directions[j]] = [directions[j], directions[i]];
          }
          for (const dir of directions) {
            if (canMove(ghost.x, ghost.y, dir, GHOST_SIZE)) {
              ghost.direction = dir;
              break;
            }
          }
        }
        ghost.x += ghost.direction.x * ghost.speed;
        ghost.y += ghost.direction.y * ghost.speed;
        ghost.element.style.left = (ghost.x * scaleX) + 'px';
        ghost.element.style.top = (ghost.y * scaleY) + 'px';
      });
    }

    // --- СТРЕЛЬБА ---
    function shootBullet() {
      if (!powerMode) return;
      if (player.lastShot && Date.now() - player.lastShot < 300) return;
      player.lastShot = Date.now();

      const bullet = document.createElement('div');
      bullet.className = 'bullet';
      bullet.style.left = (playerX + PLAYER_SIZE/2 - 3) * scaleX + 'px';
      bullet.style.top = (playerY + PLAYER_SIZE/2 - 3) * scaleY + 'px';
      gameBoard.appendChild(bullet);

      let dir = { ...playerDirection };
      if (dir.x === 0 && dir.y === 0) dir = { x: 1, y: 0 };

      bullets.push({
        element: bullet,
        x: playerX + PLAYER_SIZE/2 - 3,
        y: playerY + PLAYER_SIZE/2 - 3,
        dir: dir,
        speed: 5
      });
      playTone(1000, 0.05, "square", 0.12);
    }

    function moveBullets() {
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.x += b.dir.x * b.speed;
        b.y += b.dir.y * b.speed;
        b.element.style.left = (b.x * scaleX) + 'px';
        b.element.style.top = (b.y * scaleY) + 'px';

        // Удалить если вышел за пределы
        if (b.x < 0 || b.x > 300 || b.y < 0 || b.y > 300) {
          gameBoard.removeChild(b.element);
          bullets.splice(i, 1);
          continue;
        }

        // Проверка столкновения с призраками
        for (let j = ghosts.length - 1; j >= 0; j--) {
          const g = ghosts[j];
          const dx = b.x + 3 - (g.x + GHOST_SIZE/2);
          const dy = b.y + 3 - (g.y + GHOST_SIZE/2);
          if (Math.hypot(dx, dy) < 10) {
            // Убиваем призрака
            gameBoard.removeChild(g.element);
            ghosts.splice(j, 1);
            // Удаляем пулю
            gameBoard.removeChild(b.element);
            bullets.splice(i, 1);
            // +1 жизнь
            lives++;
            livesElement.textContent = lives;
            playTone(1200, 0.1, "square", 0.2);
            break;
          }
        }
      }
    }

    function checkCandleCollection() {
      for (let i = candles.length - 1; i >= 0; i--) {
        const candle = candles[i];
        const size = candle.power ? 10 : 4;
        const dx = playerX + 7.5 - candle.x - size / 2;
        const dy = playerY + 7.5 - candle.y - size / 2;
        const distance = Math.hypot(dx, dy);
        if (distance < 7.5 + size / 2) {
          gameBoard.removeChild(candle.element);
          candles.splice(i, 1);
          if (candle.power) {
            playPowerCandleSound();
            activatePowerMode();
          } else {
            playCandleSound();
            score += 10;
            scoreElement.textContent = score;
          }
          if (candles.length === 0) levelComplete();
        }
      }
    }
    function createCandles() {
      let count = 0;
      for (let i = 0; i < candles.length; i++) {
        if (!candles[i].power) count++;
      }
      const minCandles = 10 + 5 * level;
      for (let i = count; i < minCandles; i++) {
        const validPos = findValidPosition(CANDLE_SIZE, CANDLE_SIZE);
        createCandleAt(validPos.x, validPos.y);
      }
    }
    function activatePowerMode() {
      if (powerModeTimeout) clearTimeout(powerModeTimeout);
      powerMode = true;
      player.style.filter = 'drop-shadow(0 0 10px #00FFFA) brightness(1.5)';
      player.invincible = true;
      ghosts.forEach(g => g.element.style.filter = 'grayscale(1) brightness(1.5)');
      showAButton(true);
      powerModeTimeout = setTimeout(() => {
        powerMode = false;
        player.style.filter = '';
        player.invincible = false;
        ghosts.forEach(g => g.element.style.filter = '');
        showAButton(false);
      }, 5000);
    }
    function checkGhostCollision() {
      for (const ghost of ghosts) {
        const dx = playerX + PLAYER_SIZE / 2 - ghost.x - GHOST_SIZE / 2;
        const dy = playerY + PLAYER_SIZE / 2 - ghost.y - GHOST_SIZE / 2;
        const distance = Math.hypot(dx, dy);
        if (distance < 10) {
          if (powerMode) {
            gameBoard.removeChild(ghost.element);
            ghosts = ghosts.filter(g => g !== ghost);
            score += 100;
            scoreElement.textContent = score;
          } else if (player.invincible) {
            // Неуязвимость: ничего не происходит
          } else {
            playerDies();
          }
        }
      }
    }
    function playerDies() {
      lives--;
      livesElement.textContent = lives;
      playDeathSound();
      player.classList.add('death-anim');
      clearInterval(gameInterval);
      setTimeout(() => {
        player.classList.remove('death-anim');
        if (lives <= 0) gameOver();
        else {
          playerX = playerStart ? playerStart.x : 10 * CELL_SIZE + (CELL_SIZE - PLAYER_SIZE) / 2;
          playerY = playerStart ? playerStart.y : 10 * CELL_SIZE + (CELL_SIZE - PLAYER_SIZE) / 2;
          playerDirection = { x: 0, y: 0 };
          playerNextDirection = { x: 0, y: 0 };
          player.style.left = (playerX * scaleX) + 'px';
          player.style.top = (playerY * scaleY) + 'px';
          player.style.transform = `scale(${scaleX}, ${scaleY})`;
          gameInterval = setInterval(gameLoop, 30);
        }
      }, 800);
    }
    function levelComplete() {
      clearInterval(gameInterval);
      gameRunning = false;
      player.classList.add('win-anim');
      playLevelSound();
      completedLevelElement.textContent = level;
      levelScoreElement.textContent = score;
      levelCompleteScreen.style.display = 'flex';
      level++;
      setTimeout(() => {
        player.classList.remove('win-anim');
        levelCompleteScreen.style.display = 'none';
        applyWallStyle(level);
        const elementsToKeep = [startScreen, gameOverScreen, levelCompleteScreen, levelIndicator];
        const children = Array.from(gameBoard.children);
        for (const child of children) {
          if (!elementsToKeep.includes(child)) gameBoard.removeChild(child);
        }
        ghosts = [];
        candles = [];
        walls = [];
        bullets.forEach(b => gameBoard.removeChild(b.element));
        bullets = [];
        powerMode = false;
        showAButton(false);
        if (powerModeTimeout) clearTimeout(powerModeTimeout);
        levelIndicator.textContent = "LEVEL " + level;
        createMaze((level - 1) % mazeLayouts.length);

        playerX = playerStart ? playerStart.x : 10 * CELL_SIZE + (CELL_SIZE - PLAYER_SIZE) / 2;
        playerY = playerStart ? playerStart.y : 10 * CELL_SIZE + (CELL_SIZE - PLAYER_SIZE) / 2;
        player = document.createElement('div');
        player.className = 'player';
        player.style.left = (playerX * scaleX) + 'px';
        player.style.top = (playerY * scaleY) + 'px';
        player.style.transform = `scale(${scaleX}, ${scaleY})`;
        player.innerHTML = createPlayerSvg();
        player.speed = 1.5;
        player.invincible = false;
        player.lastShot = 0;
        gameBoard.appendChild(player);
        createGhosts();
        createCandles();
        startGame();
      }, 1200);
    }
    function gameOver() {
      clearInterval(gameInterval);
      gameRunning = false;
      finalScoreElement.textContent = score;
      finalLevelElement.textContent = level;
      gameOverScreen.style.display = 'flex';
    }

    // --- Геймпад управление ---
    function setupGamepadControls() {
      dpadUp.addEventListener('touchstart', e => { e.preventDefault(); playerNextDirection = { x: 0, y: -1 }; });
      dpadDown.addEventListener('touchstart', e => { e.preventDefault(); playerNextDirection = { x: 0, y: 1 }; });
      dpadLeft.addEventListener('touchstart', e => { e.preventDefault(); playerNextDirection = { x: -1, y: 0 }; });
      dpadRight.addEventListener('touchstart', e => { e.preventDefault(); playerNextDirection = { x: 1, y: 0 }; });
      abtnA.addEventListener('touchstart', e => {
        e.preventDefault();
        if (abtnA.classList.contains('active')) shootBullet();
      });
    }
    function showAButton(active) {
      if (active) abtnA.classList.add('active');
      else abtnA.classList.remove('active');
    }

    document.addEventListener('DOMContentLoaded', () => {
      startBtn.addEventListener('click', () => {
        initGame();
        startGame();
      });
      restartBtn.addEventListener('click', () => {
        initGame();
        startGame();
      });
      setupGamepadControls();
    });

    document.addEventListener('keydown', e => {
      if (!gameRunning) return;
      switch (e.key) {
        case 'ArrowUp': case 'w': case 'W': playerNextDirection = { x: 0, y: -1 }; break;
        case 'ArrowDown': case 's': case 'S': playerNextDirection = { x: 0, y: 1 }; break;
        case 'ArrowLeft': case 'a': case 'A': playerNextDirection = { x: -1, y: 0 }; break;
        case 'ArrowRight': case 'd': case 'D': playerNextDirection = { x: 1, y: 0 }; break;
        case ' ':
        case 'j':
        case 'J':
          shootBullet();
          break;
      }
      if (playerDirection.x === 0 && playerDirection.y === 0) {
        playerDirection = { ...playerNextDirection };
      }
    });
    window.addEventListener('resize', adjustGameBoardSize);
    window.addEventListener('orientationchange', () => setTimeout(adjustGameBoardSize, 200));
  </script>
</body>
</html>